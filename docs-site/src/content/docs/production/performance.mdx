---
title: Performance Optimization
description: Optimize WebAssembly components for production using Wizer pre-initialization
---

# Performance Optimization

Learn how to optimize WebAssembly components for faster startup times and better runtime performance.

## Wizer Pre-initialization

Wizer is a WebAssembly pre-initialization tool that can dramatically improve startup performance by running initialization code at build time.

### Basic Usage

```starlark
load("@rules_wasm_component//wasm:defs.bzl", "wasm_component_wizer_library")

wasm_component_wizer_library(
    name = "optimized_component",
    component = ":my_component",
    init_func = "init",
    allow_wasi = True,
)
```

> **ðŸ“‹ Rule Reference:** For complete details on performance optimization rules, see [`wasm_component_wizer_library`](/reference/rules/#wasm_component_wizer_library).

### Performance Gains

Wizer can provide:

- **1.35-6x faster startup** for typical components
- Reduced cold start latency
- Pre-computed initialization state

### Best Practices

1. **Identify expensive initialization** - Profile your component to find slow startup code
2. **Design for pre-initialization** - Structure code to separate initialization from runtime logic
3. **Test thoroughly** - Ensure pre-initialized state is correct

## Ahead-of-Time (AOT) Compilation

WebAssembly components can be precompiled to native machine code using Wasmtime's AOT compilation for dramatically faster startup times.

### Basic AOT Usage

```starlark
load("@rules_wasm_component//wasm:defs.bzl", "wasm_precompile", "wasm_run")

# Precompile component for production
wasm_precompile(
    name = "my_component_aot",
    component = ":my_component",
    optimization_level = "2",    # Speed + size optimization
    strip_symbols = True,        # Reduce size by ~25%
)

# Runtime execution uses AOT automatically
wasm_run(
    name = "run_optimized",
    component = ":my_component_aot",
)
```

### AOT Performance Benefits

- **Zero JIT compilation** - Skip translation and codegen at runtime
- **7x size reduction** - Optimized builds (2.7MB â†’ 388KB)
- **Faster startup** - Immediate execution of native code
- **Bazel cache friendly** - Share precompiled modules across teams

### Optimization Levels

```starlark
# Development builds with debug info
wasm_precompile(
    name = "component_debug",
    component = ":my_component",
    optimization_level = "0",
    debug_info = True,
)

# Production builds optimized for speed
wasm_precompile(
    name = "component_speed",
    component = ":my_component",
    optimization_level = "2",
)

# Production builds optimized for size
wasm_precompile(
    name = "component_size",
    component = ":my_component",
    optimization_level = "s",
    strip_symbols = True,
)
```

### Cross-Platform AOT

```starlark
# Compile for specific target architecture
wasm_precompile(
    name = "component_x86_64",
    component = ":my_component",
    target_triple = "x86_64-unknown-linux-gnu",
    optimization_level = "2",
)
```

### When to Use AOT

- **Production deployments** - Faster startup is critical
- **Edge computing** - Minimize cold start latency
- **High-frequency execution** - Startup cost amortizes quickly
- **Resource-constrained environments** - Smaller memory footprint

## Build Optimizations

### Compiler Flags

```starlark
rust_wasm_component(
    name = "optimized_rust_component",
    srcs = ["lib.rs"],
    wit = "component.wit",
    optimization = "release",  # Use release optimizations
    features = ["opt-level=s"], # Optimize for size
)
```

### Profile-Based Optimization

Use different optimization profiles:

```starlark
rust_wasm_component(
    name = "my_component_all_profiles",
    srcs = ["lib.rs"],
    wit = "component.wit",
    profiles = ["debug", "release", "size"],
)
```

## Runtime Performance

### Memory Management

- Use appropriate memory allocation strategies
- Profile memory usage with tools like `wasm-profiler`
- Consider memory pre-allocation for performance-critical paths

### Function Call Optimization

- Minimize host function calls
- Batch operations when possible
- Use efficient data serialization

## Measurement and Profiling

Track key metrics:

- Component load time
- First function call latency
- Memory usage
- Execution time

## Next Steps

- [Deployment Guide](/production/deployment-guide/) - Production deployment strategies
- [Component Signing](/security/component-signing/) - Secure your optimized components
