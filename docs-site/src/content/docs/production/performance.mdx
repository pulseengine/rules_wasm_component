---
title: Performance Optimization
description: Optimize WebAssembly components for production using Wizer pre-initialization
---

# Performance Optimization

Learn how to optimize WebAssembly components for faster startup times and better runtime performance.

## Wizer Pre-initialization

Wizer is a WebAssembly pre-initialization tool that can dramatically improve startup performance by running initialization code at build time.

### Basic Usage

```starlark
load("@rules_wasm_component//wasm:defs.bzl", "wasm_component_wizer_library")

wasm_component_wizer_library(
    name = "optimized_component",
    component = ":my_component",
    init_func = "init",
    allow_wasi = True,
)
```

> **ðŸ“‹ Rule Reference:** For complete details on performance optimization rules, see [`wasm_component_wizer_library`](/reference/rules/#wasm_component_wizer_library).

### Performance Gains

Wizer can provide:

- **1.35-6x faster startup** for typical components
- Reduced cold start latency
- Pre-computed initialization state

### Best Practices

1. **Identify expensive initialization** - Profile your component to find slow startup code
2. **Design for pre-initialization** - Structure code to separate initialization from runtime logic
3. **Test thoroughly** - Ensure pre-initialized state is correct

## Ahead-of-Time (AOT) Compilation

WebAssembly components can be precompiled to native machine code using Wasmtime's AOT compilation for dramatically faster startup times.

### Basic AOT Usage

```starlark
load("@rules_wasm_component//wasm:defs.bzl", "wasm_precompile", "wasm_run")

# Precompile component for production (default: no debug info)
wasm_precompile(
    name = "my_component_aot",
    component = ":my_component",
    optimization_level = "2",    # Speed + size optimization
)

# Runtime execution uses AOT automatically
wasm_run(
    name = "run_optimized",
    component = ":my_component_aot",
)
```

### AOT Performance Benefits

- **Zero JIT compilation** - Skip translation and codegen at runtime
- **87% size reduction** - Production builds exclude debug info (2.8MB â†’ 343KB)
- **Faster startup** - Immediate execution of native code
- **Cross-platform compilation** - Build for any architecture without QEMU
- **Bazel cache friendly** - Share precompiled modules across teams

### Debug Info vs Production Builds

```starlark
# Development builds with debug info (~8x larger but debuggable)
wasm_precompile(
    name = "component_debug",
    component = ":my_component",
    optimization_level = "0",
    debug_info = True,  # Include DWARF debug information
)

# Production builds (default: no debug info, 87% smaller)
wasm_precompile(
    name = "component_production",
    component = ":my_component",
    optimization_level = "2",  # debug_info = False by default
)

# Production builds optimized for size
wasm_precompile(
    name = "component_size",
    component = ":my_component",
    optimization_level = "s",  # Size-optimized + no debug info
)
```

### Cross-Platform AOT

```starlark
# Compile for specific target architecture
wasm_precompile(
    name = "component_x86_64",
    component = ":my_component",
    target_triple = "x86_64-unknown-linux-gnu",
    optimization_level = "2",
)
```

### When to Use AOT

- **Production deployments** - Faster startup is critical
- **Edge computing** - Minimize cold start latency
- **High-frequency execution** - Startup cost amortizes quickly
- **Resource-constrained environments** - Smaller memory footprint

## AOT Embedding for Multi-Architecture Deployment

**Embed multiple AOT artifacts as custom sections** within a single WebAssembly component for universal deployment. This enables signing and distributing one component that contains optimized native code for multiple architectures.

### Basic AOT Embedding

```starlark
load("@rules_wasm_component//wasm:defs.bzl",
     "wasm_precompile", "wasm_embed_aot", "wasm_extract_aot")

# Create AOT artifacts for different architectures
wasm_precompile(
    name = "component_x64",
    component = ":my_component",
    target_triple = "x86_64-unknown-linux-gnu",
    optimization_level = "2",
)

wasm_precompile(
    name = "component_arm64",
    component = ":my_component",
    target_triple = "aarch64-unknown-linux-gnu",
    optimization_level = "2",
)

wasm_precompile(
    name = "component_portable",
    component = ":my_component",
    target_triple = "pulley64",  # Architecture-independent
    optimization_level = "2",
)

# Embed all AOT artifacts into single component
wasm_embed_aot(
    name = "universal_component",
    component = ":my_component",
    aot_artifacts = {
        "linux_x64": ":component_x64",
        "linux_arm64": ":component_arm64",
        "portable": ":component_portable",
    },
)
```

### Runtime Extraction

```starlark
# Extract specific architecture at runtime
wasm_extract_aot(
    name = "extracted_x64",
    component = ":universal_component",
    target_name = "linux_x64",
)
```

### AOT Embedding Benefits

- **Single artifact distribution** - One component works everywhere
- **Signature compatibility** - Maintains WebAssembly format for signing
- **Architecture-specific optimization** - Each platform gets optimal native code
- **Fallback support** - Include portable bytecode for unknown architectures
- **87% size reduction** - Production builds exclude debug symbols

> **ðŸ“‹ Rule Reference:** For complete details on AOT embedding rules, see [`wasm_embed_aot`](/reference/rules/#wasm_embed_aot) and [`wasm_extract_aot`](/reference/rules/#wasm_extract_aot).

## Build Optimizations

### Compiler Flags

```starlark
rust_wasm_component(
    name = "optimized_rust_component",
    srcs = ["lib.rs"],
    wit = "component.wit",
    optimization = "release",  # Use release optimizations
    features = ["opt-level=s"], # Optimize for size
)
```

### Profile-Based Optimization

Use different optimization profiles:

```starlark
rust_wasm_component(
    name = "my_component_all_profiles",
    srcs = ["lib.rs"],
    wit = "component.wit",
    profiles = ["debug", "release", "size"],
)
```

## Runtime Performance

### Memory Management

- Use appropriate memory allocation strategies
- Profile memory usage with tools like `wasm-profiler`
- Consider memory pre-allocation for performance-critical paths

### Function Call Optimization

- Minimize host function calls
- Batch operations when possible
- Use efficient data serialization

## Measurement and Profiling

Track key metrics:

- Component load time
- First function call latency
- Memory usage
- Execution time

## Next Steps

- [Deployment Guide](/production/deployment-guide/) - Production deployment strategies
- [Component Signing](/security/component-signing/) - Secure your optimized components
