---
title: WebAssembly Component Rules
description: Modern Bazel rules for building and composing WebAssembly components with multi-language support.
template: splash
hero:
  tagline: Build production-ready WebAssembly components with Bazel
  image:
    file: ../../assets/houston.webp
  actions:
    - text: Quick Start
      link: /getting-started/
      icon: right-arrow
      variant: primary
    - text: View Examples
      link: /examples/basic/
      icon: external
    - text: GitHub Repository
      link: https://github.com/pulseengine/rules_wasm_component
      icon: github
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## What is the WebAssembly Component Model?

The **WebAssembly Component Model** is a revolutionary approach to building portable, secure, and composable software. Think of it as "microservices for WebAssembly" - you can build small, focused components in any language and connect them together like LEGO blocks.

### Why Should You Care?

**ðŸ”— Language Freedom**: Write your auth service in Rust, your API in Go, your frontend in JavaScript, and your ML pipeline in Python - all running together seamlessly.

**ðŸš€ Performance**: Near-native speed with WebAssembly's efficiency, but with the safety and portability of sandboxed execution.

**ðŸ“¦ True Portability**: Build once, run anywhere - from edge devices to cloud servers, from browsers to embedded systems.

**ðŸ”’ Security by Default**: Each component runs in its own sandbox with explicit interfaces - no hidden dependencies or side effects.

### Real-World Use Cases

- **Microservices**: Replace Docker containers with lightweight WASM components
- **Plugin Systems**: Add extensibility to your apps with secure, fast plugins
- **Edge Computing**: Deploy the same code to CDN edges, IoT devices, and cloud
- **Multi-language Projects**: Combine the best tools from different ecosystems

## Why rules_wasm_component?

Building WebAssembly components traditionally involves complex toolchains and manual configuration. **rules_wasm_component** makes it as easy as:

```python
rust_wasm_component_bindgen(
    name = "my_service",
    srcs = ["src/lib.rs"],
    wit = ":my_interfaces",
)
```

That's it! Bazel handles the complexity while you focus on building great software.

## Features

<CardGrid stagger>
	<Card title="Rust Integration" icon="seti:rust">
		Seamless integration with rules_rust for building WebAssembly components with wit-bindgen.
	</Card>
	<Card title="Go Support" icon="seti:go">
		TinyGo v0.38.0 with WASI Preview 2 component support and official BytecodeAlliance modules.
	</Card>
	<Card title="C++ Components" icon="seti:cpp">
		Native C++ component development with WASI SDK and Preview2 direct compilation.
	</Card>
	<Card title="JavaScript/TypeScript" icon="seti:javascript">
		ComponentizeJS integration for building WebAssembly components from JS/TS source code.
	</Card>
	<Card title="WAC Composition" icon="puzzle">
		WebAssembly Composition (WAC) support for building complex multi-component systems.
	</Card>
	<Card title="OCI Publishing" icon="docker">
		Publish and distribute components via container registries with multi-registry support.
	</Card>
	<Card title="Digital Signing" icon="lock">
		Component signing with wasmsign2 and verification for secure deployments.
	</Card>
	<Card title="Performance" icon="rocket">
		Wizer pre-initialization for 1.35-6x startup performance improvements.
	</Card>
	<Card title="WRPC Integration" icon="connection">
		Remote procedure calls between components with wrpc bindings and distributed architecture.
	</Card>
	<Card title="Multi-Architecture" icon="globe">
		Build and distribute components for multiple WebAssembly targets and platforms.
	</Card>
	<Card title="Enterprise Security" icon="shield">
		Security policies, component signing verification, and enterprise-grade deployment controls.
	</Card>
	<Card title="Advanced Composition" icon="workflow">
		Microservices patterns, distributed systems, and hybrid local/remote component orchestration.
	</Card>
</CardGrid>

## Quick Example

Create your first WebAssembly component in just a few steps:

```python title="BUILD.bazel"
load("@rules_wasm_component//wit:defs.bzl", "wit_library")
load("@rules_wasm_component//rust:defs.bzl", "rust_wasm_component_bindgen")

wit_library(
    name = "hello_interfaces",
    srcs = ["hello.wit"],
    package_name = "hello:world@1.0.0",
)

rust_wasm_component_bindgen(
    name = "hello_component",
    srcs = ["src/lib.rs"],
    wit = ":hello_interfaces",
)
```

<div class="demo-buttons">
  <a href="https://github.com/pulseengine/rules_wasm_component/tree/main/examples/basic" class="demo-button">
    View Examples
  </a>
  <a href="/getting-started/" class="demo-button">
    Read the Guide
  </a>
  <a href="/examples/" class="demo-button">
    See Examples
  </a>
</div>

## Supported Languages

Build WebAssembly components in your preferred language:

<div class="feature-grid">
  <div class="feature-card">
    <h3>Rust</h3>
    <p>Full Component Model support with wit-bindgen integration and multiple build profiles.</p>
    <a href="/languages/rust/">Learn more â†’</a>
  </div>
  <div class="feature-card">
    <h3>Go</h3>
    <p>TinyGo v0.38.0 with WASI Preview 2 and official BytecodeAlliance Go modules.</p>
    <a href="/languages/go/">Learn more â†’</a>
  </div>
  <div class="feature-card">
    <h3>C++</h3>
    <p>Native Preview2 compilation with WASI SDK and comprehensive error handling.</p>
    <a href="/languages/cpp/">Learn more â†’</a>
  </div>
  <div class="feature-card">
    <h3>JavaScript</h3>
    <p>ComponentizeJS with NPM dependencies, TypeScript support, and optimization.</p>
    <a href="/languages/javascript/">Learn more â†’</a>
  </div>
</div>
