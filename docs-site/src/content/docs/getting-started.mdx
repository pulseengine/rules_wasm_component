---
title: Getting Started
description: Quick start guide for building WebAssembly components with Bazel
---

## Welcome to the Future of Software Components

Ready to build software that's **portable**, **secure**, and **fast**? WebAssembly components let you write code once and run it anywhere - from web browsers to servers, IoT devices to desktop apps.

Think of WebAssembly components as **smart LEGO blocks** for software:
- **Plug-and-play**: Components from different languages work together seamlessly
- **Secure by design**: Each component runs in its own sandbox
- **Near-native speed**: Performance similar to compiled C/C++
- **Universal deployment**: Same component runs on any platform

**rules_wasm_component** makes building these components as easy as traditional software - no complex WebAssembly knowledge required!

## Prerequisites

- **Bazelisk** (recommended) - Automatically manages Bazel versions
  ```bash
  # Quick install on macOS
  brew install bazelisk

  # Or cross-platform via NPM
  npm install -g @bazel/bazelisk
  ```
- **Git** - For cloning repositories
- **Language-specific tools** (installed automatically by Bazel):
  - Rust: `cargo`, `rustc` (via rules_rust)
  - Go: TinyGo v0.38.0 (via toolchain)
  - C++: WASI SDK (via toolchain)
  - JavaScript: Node.js, jco (via toolchain)

## Installation

Add rules_wasm_component to your Bazel project:

### 1. Add to MODULE.bazel

```python title="MODULE.bazel"
bazel_dep(name = "rules_wasm_component", version = "1.0.0")

# Optional: Configure WASM toolchain version
wasm_toolchain = use_extension(
    "@rules_wasm_component//wasm:extensions.bzl",
    "wasm_toolchain",
)
wasm_toolchain.register(
    name = "wasm_tools",
    version = "1.235.0",  # Optional, defaults to latest stable
)

# Optional: Configure TinyGo toolchain version
tinygo = use_extension("@rules_wasm_component//wasm:extensions.bzl", "tinygo")
tinygo.register(
    name = "tinygo",
    tinygo_version = "0.38.0"  # Optional, defaults to 0.38.0
)
```

### 2. Add Rust dependencies (if using Rust)

```python title="MODULE.bazel"
bazel_dep(name = "rules_rust", version = "0.62.0")

# Configure crate dependencies
crate = use_extension("@rules_rust//crate_universe:extension.bzl", "crate")
crate.from_cargo(
    name = "crates",
    cargo_lockfile = "//:Cargo.lock",
    manifests = ["//:Cargo.toml"],
)
use_repo(crate, "crates")
```

```toml title="Cargo.toml"
[package]
name = "my-components"
version = "0.1.0"
edition = "2021"

[dependencies]
wit-bindgen = { version = "0.30.0", default-features = false, features = ["realloc"] }
```

## Your First Component

Let's create a simple "Hello World" WebAssembly component to see how easy it is.

**What we're building**: A self-contained WebAssembly component that exports a "greet" function. Unlike traditional libraries, this component can be called from any language and runs in complete isolation.

**The process**: We'll define an interface (what functions the component provides), implement the logic in Rust, and let Bazel handle all the WebAssembly compilation magic.

### 1. Define the WIT Interface

**WIT (WebAssembly Interface Types)** is like a contract - it describes what functions your component provides and what types they use. This lets other components (in any language) know how to call your code.

import CodeFromFile from '@components/CodeFromFile.astro';

<CodeFromFile file="examples/basic/wit/hello.wit" title="examples/basic/wit/hello.wit" />

This defines a "world" (think of it as an API) with one function: `greet` that takes a string and returns a string.

### 2. Create the Build File

**Bazel BUILD files** tell the build system how to compile your code. Here we're saying "take this WIT interface and this Rust code, and build me a WebAssembly component":

<CodeFromFile file="examples/basic/BUILD.bazel" title="examples/basic/BUILD.bazel" />

The `wit_library` creates the interface definitions, and `rust_wasm_component_bindgen` compiles your Rust code into a WebAssembly component that implements that interface.

### 3. Implement the Component

**The Rust implementation** is just normal Rust code. The `wit-bindgen` macro automatically generates the glue code that connects your Rust functions to the WebAssembly component interface:

<CodeFromFile file="examples/basic/src/lib.rs" title="examples/basic/src/lib.rs" />

### 4. Build the Component

**That's it!** Bazel handles downloading the WebAssembly toolchain, compiling your Rust code, and packaging everything into a component:

```bash
# Build the component
bazel build //:hello_component

# Test with wasmtime (WebAssembly runtime)
wasmtime run --wasi preview2 bazel-bin/hello_component.wasm
```

**What just happened?** Bazel automatically:
- Downloaded the Rust toolchain and WebAssembly tools
- Compiled your Rust code to WebAssembly
- Generated bindings from your WIT interface
- Packaged everything into a `.wasm` component file

Your component is now ready to run on any platform that supports WebAssembly!

<div class="demo-buttons">
  <a href="https://stackblitz.com/github/pulseengine/rules_wasm_component/tree/main/examples/basic" class="demo-button">
    Try this example in StackBlitz
  </a>
</div>

## What's Next?

Now that you have your first component working, explore more advanced features:

### Language-Specific Guides
- [**Rust Components**](/languages/rust/) - Advanced Rust patterns and optimization
- [**Go Components**](/languages/go/) - TinyGo with WASI Preview 2
- [**C++ Components**](/languages/cpp/) - Native C++ development
- [**JavaScript Components**](/languages/javascript/) - ComponentizeJS integration

### Advanced Topics
- [**Toolchain Configuration**](/guides/toolchain-configuration/) - Strategies, versions, CI/CD setup
- [**Component Composition**](/composition/wac/) - Building multi-component systems
- [**OCI Publishing**](/production/publishing/) - Distribute via container registries
- [**Performance Optimization**](/production/performance/) - Wizer pre-initialization

### Examples
- [**Basic Component**](/examples/basic/) - Simple hello world
- [**Calculator (C++)**](/examples/calculator/) - Math operations with error handling
- [**HTTP Service (Go)**](/examples/http-service/) - Web service component
- [**Multi-Language System**](/examples/multi-language/) - Polyglot composition

## Getting Help

- **Documentation**: Browse this site for comprehensive guides
- **Examples**: Check the `/examples` directory in the repository
- **Issues**: Report bugs on [GitHub Issues](https://github.com/pulseengine/rules_wasm_component/issues)
- **Discussions**: Ask questions in [GitHub Discussions](https://github.com/pulseengine/rules_wasm_component/discussions)

## Performance Note

<div class="perf-indicator">
Fast Builds: Bazel's incremental builds make iteration quick
</div>

Components built with these rules benefit from:
- **Bazel's build caching** - Only rebuild what changed
- **Hermetic toolchains** - Consistent builds across environments
- **Parallel compilation** - Build multiple components simultaneously
- **Wizer pre-initialization** - 1.35-6x startup performance improvements
