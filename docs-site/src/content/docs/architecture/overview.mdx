---
title: Architecture Overview
description: Complete WebAssembly component development workflow and toolchain architecture
---

# WebAssembly Component Architecture

## The Big Picture

Think of WebAssembly components as **intelligent LEGO blocks for software**. Each block has clear interfaces (the "studs" and "holes"), can be built in any language, and connects perfectly with blocks built in other languages.

**What makes this architecture special:**
- **Language Freedom** - Write each component in the best language for the job
- **True Portability** - Same component runs everywhere WebAssembly is supported
- **Safe Composition** - Components can't interfere with each other
- **Easy Distribution** - Components are just files that can be stored anywhere

**Real-world analogy:** Imagine building a house where the foundation is written in Rust (for performance), the plumbing in Go (for simplicity), the electrical system in C++ (for hardware access), and the smart home controls in JavaScript (for web integration). All these parts work together perfectly because they follow the same "building code" (WebAssembly Component Model).

## How It All Works Together

Understanding the complete development workflow from WIT interfaces to deployed components, including multi-language support and advanced composition patterns.

## Development Workflow Overview

**The journey from code to component** follows a predictable path, regardless of which language you use. Here's what happens behind the scenes when you build a component.

### Core Development Pipeline

**This diagram shows the transformation process** - from your interface definition to a deployed component. Notice how different languages all converge to the same WebAssembly format:

```mermaid
graph TD
    A[WIT Interface Definition] --> B[Language-Specific Bindgen]
    B --> C[Component Implementation]
    C --> D[WebAssembly Core Module]
    D --> E[WASI Adapter Integration]
    E --> F[Component Wrapping]
    F --> G[Validation & Optimization]
    G --> H[Component Registry/Deployment]

    B1[wit-bindgen-rust] --> C1[Rust Implementation]
    B2[wit-bindgen-go] --> C2[Go Implementation]
    B3[wit-bindgen-c] --> C3[C++ Implementation]
    B4[jco] --> C4[JS Implementation]

    B --> B1
    B --> B2
    B --> B3
    B --> B4

    C1 --> D
    C2 --> D
    C3 --> D
    C4 --> D

    style A fill:#e1f5fe
    style H fill:#f3e5f5
    style G fill:#fff3e0
```

### Tool Ecosystem

**Behind every component build is an orchestra of specialized tools.** Each tool has one job and does it well - the build system coordinates them all so you don't have to think about it:

**How the tools work together:**
- **Interface tools** parse your WIT files and validate the API contracts
- **Code generators** create language-specific bindings so your code can implement the interfaces
- **Language compilers** turn your implementation into WebAssembly modules
- **WebAssembly tools** package modules into components and optimize them
- **Composition tools** connect components together into applications

```mermaid
graph LR
    subgraph "Interface Definition"
        WIT[WIT Files]
        WL[wit_library rule]
    end

    subgraph "Code Generation"
        WBR[wit-bindgen-rust]
        WBG[wit-bindgen-go]
        WBC[wit-bindgen-c]
        JCO[jco/componentize-js]
    end

    subgraph "Language Toolchains"
        RUST[Rust Compiler]
        TINYGO[TinyGo Compiler]
        WASISDK[WASI SDK]
        NODE[Node.js]
    end

    subgraph "WebAssembly Tools"
        WT[wasm-tools]
        WZ[Wizer]
        VA[WASI Adapters]
    end

    subgraph "Composition & Deployment"
        WAC[WAC Composer]
        WKG[WKG Registry]
        OCI[OCI Registries]
    end

    WIT --> WL
    WL --> WBR
    WL --> WBG
    WL --> WBC
    WL --> JCO

    WBR --> RUST
    WBG --> TINYGO
    WBC --> WASISDK
    JCO --> NODE

    RUST --> WT
    TINYGO --> WT
    WASISDK --> WT
    NODE --> WT

    WT --> WZ
    WT --> VA
    WZ --> WAC
    VA --> WAC
    WAC --> WKG
    WAC --> OCI
```

## Language-Specific Implementation Flows

**Each language has its own path to WebAssembly,** but they all end up at the same destination. Understanding these flows helps you pick the right language for your components and debug issues when they arise.

### Rust Component Development

**Rust has the most mature WebAssembly toolchain** and produces the smallest, fastest components. The process follows this pattern:

1. **WIT Interface Processing**: The `wit_library` rule processes WIT files and validates interface definitions
2. **Binding Generation**: `rust_wasm_component_bindgen` generates Rust traits and types
3. **Component Implementation**: Developer implements the generated traits
4. **Module Compilation**: Rust compiler produces WebAssembly core module
5. **Component Wrapping**: `wasm-tools component new` wraps the module with component metadata
6. **Validation**: `wasm-tools validate` ensures component compliance

### Go Component Development

**Go components use TinyGo instead of the standard Go compiler** because TinyGo is specifically designed for WebAssembly and embedded systems. The workflow is similar to Rust but with Go-specific tooling:

1. **WIT Processing**: Same `wit_library` rule as other languages
2. **Go Binding Generation**: `go_wit_bindgen` creates Go interfaces and types
3. **TinyGo Compilation**: TinyGo compiler with WASI Preview 2 target
4. **Adapter Integration**: WASI snapshot preview1 adapter for compatibility
5. **Component Assembly**: Same component wrapping process as Rust

### Multi-Language Architecture

**This is where the magic happens** - different languages implementing the same interfaces, creating components that can work together seamlessly. Each language brings its strengths to the table:

```mermaid
flowchart TB
    subgraph "Shared Interface Layer"
        WIT1[calculator.wit]
        WIT2[http-service.wit]
        WIT3[storage.wit]
    end

    subgraph "Language Implementations"
        RUST1[Rust Calculator]
        GO1[Go HTTP Service]
        CPP1[C++ Storage]
        JS1[JS Frontend]
    end

    subgraph "Component Layer"
        COMP1[Calculator Component]
        COMP2[HTTP Component]
        COMP3[Storage Component]
        COMP4[Frontend Component]
    end

    subgraph "Composition Layer"
        WAC1[microservices.wac]
        SYS[Distributed System]
    end

    WIT1 --> RUST1
    WIT2 --> GO1
    WIT3 --> CPP1
    WIT1 --> JS1

    RUST1 --> COMP1
    GO1 --> COMP2
    CPP1 --> COMP3
    JS1 --> COMP4

    COMP1 --> WAC1
    COMP2 --> WAC1
    COMP3 --> WAC1
    COMP4 --> WAC1

    WAC1 --> SYS
```

## Advanced Features Integration

**Beyond basic components,** the architecture supports sophisticated patterns for production systems.

### Wizer Pre-initialization

**Think of Wizer as "instant coffee" for WebAssembly components.** Instead of going through the startup process every time, Wizer "pre-brews" your component so it starts instantly:

**How it works:** Wizer runs your component's initialization code once during the build, takes a snapshot of the initialized state, and bakes that into the final component. When the component starts in production, it skips all the initialization and jumps straight to the ready state.

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant Wizer as Wizer Tool
    participant Runtime as Runtime Host

    Dev->>Wizer: Core Module + Init Function
    Wizer->>Wizer: Execute Initialization
    Wizer->>Wizer: Snapshot Memory State
    Wizer->>Dev: Pre-initialized Module
    Dev->>Runtime: Deploy Optimized Component
    Runtime->>Runtime: Skip Initialization (1.35-6x faster)
```

### Component Composition with WAC

**WAC (WebAssembly Composition) is like a blueprint for connecting components.** Just as an architect draws plans showing how rooms connect in a building, WAC files describe how components connect in an application:

1. **Component Registry**: Components stored in OCI registries or local builds
2. **Composition Definition**: WAC files describe component relationships
3. **Dependency Resolution**: Automatic component and dependency fetching
4. **Runtime Assembly**: Dynamic component linking and instantiation

### OCI Registry Integration

**Components can be stored and shared just like Docker images,** but without the container overhead. This enables easy distribution and version management:

```mermaid
graph TB
    subgraph "Local Development"
        BUILD[bazel build]
        COMP[Component Binary]
    end

    subgraph "Registry Publishing"
        PUSH[oci_push rule]
        REG[OCI Registry]
        META[Component Metadata]
    end

    subgraph "Consumption"
        PULL[oci_pull rule]
        DEP[Dependency Resolution]
        COMPOSE[WAC Composition]
    end

    BUILD --> COMP
    COMP --> PUSH
    PUSH --> REG
    PUSH --> META

    REG --> PULL
    META --> DEP
    PULL --> COMPOSE
    DEP --> COMPOSE
```

## Key Architectural Principles

**These principles make the architecture reliable and predictable** for teams building production systems.

### Hermetic Builds

**"Hermetic" means completely self-contained - no surprises from different environments.** Your builds work the same way on your laptop, in CI, and on your teammate's machine:

- **Language Toolchains**: Rust, TinyGo, WASI SDK managed as Bazel toolchains
- **WebAssembly Tools**: wasm-tools, wizer, wit-bindgen downloaded from releases
- **Cross-Platform**: Automatic platform detection and tool selection
- **Reproducible**: Exact version pinning ensures consistent builds

### Component Model Compliance

**Standards compliance ensures your components work everywhere.** Following the WebAssembly Component Model spec means your components can interoperate with any other compliant component, regardless of language or toolchain:

- **Interface Types**: Rich type system with records, variants, and resources
- **World Isolation**: Clear component boundaries and capabilities
- **WASI Integration**: Standardized system interface support
- **Versioning**: Semantic versioning for component interfaces

### Performance Optimization

**The architecture is designed for performance at every level** - from build time to runtime. These optimizations happen automatically or can be configured based on your needs:

- **Build-time**: Release optimizations, dead code elimination
- **Runtime**: Wizer pre-initialization, efficient memory layouts
- **Composition**: Lazy loading, dynamic linking strategies
- **Deployment**: Container registry caching, bandwidth optimization

This architecture enables building scalable, maintainable WebAssembly applications while preserving the benefits of strong typing, component isolation, and cross-language interoperability.
