"""Repository rule for downloading WASM components from JSON registry.

This provides a registry-backed alternative to http_file for WASM components,
ensuring all downloads use the centralized checksum registry.
"""

load("//checksums:registry.bzl", "get_github_repo", "get_tool_info")

def _wasm_component_download_impl(ctx):
    """Download a WASM component using the JSON registry."""
    tool_name = ctx.attr.tool_name
    version = ctx.attr.version
    platform = ctx.attr.platform

    # Try configured platform first, then fallback to common names
    platforms_to_try = [platform] if platform else ["wasm", "wasm_component"]

    # Get tool info from registry
    tool_info = None
    for platform_name in platforms_to_try:
        tool_info = get_tool_info(ctx, tool_name, version, platform_name)
        if tool_info:
            break

    if not tool_info:
        fail("Tool '{}' version '{}' not found in registry. Check //checksums/tools/{}.json (tried platforms: {})".format(
            tool_name,
            version,
            tool_name,
            ", ".join(platforms_to_try),
        ))

    sha256 = tool_info.get("sha256")
    if not sha256:
        fail("No SHA256 checksum found for '{}' version '{}'".format(tool_name, version))

    # Build download URL
    github_repo = get_github_repo(ctx, tool_name)
    if not github_repo:
        fail("GitHub repository not found for tool '{}'".format(tool_name))

    # Check for custom URL or build from suffix
    url = tool_info.get("url")
    if not url:
        url_suffix = tool_info.get("url_suffix")
        if not url_suffix:
            fail("Neither 'url' nor 'url_suffix' found for '{}' version '{}'".format(tool_name, version))

        # Build URL from GitHub releases pattern
        url = "https://github.com/{}/releases/download/v{}/{}".format(
            github_repo,
            version,
            url_suffix,
        )

    # Download the WASM file into 'file/' subdirectory (matches http_file structure)
    filename = ctx.attr.filename or "{}.wasm".format(tool_name)
    ctx.download(
        url = url,
        sha256 = sha256,
        output = "file/" + filename,
    )

    # Create root BUILD file (empty, just marks as package)
    ctx.file("BUILD.bazel", "# Generated by wasm_component_download\n")

    # Create BUILD file in 'file/' subdirectory (matches http_file structure)
    # This allows referencing as @repo//file or @repo//file:file
    ctx.file("file/BUILD.bazel", """
# Generated by wasm_component_download
# Matches http_file structure for backward compatibility

exports_files(["{filename}"])

filegroup(
    name = "file",
    srcs = ["{filename}"],
    visibility = ["//visibility:public"],
)
""".format(filename = filename))

wasm_component_download = repository_rule(
    implementation = _wasm_component_download_impl,
    attrs = {
        "tool_name": attr.string(
            doc = "Name of the tool in the JSON registry (e.g., 'loom', 'wsc')",
            mandatory = True,
        ),
        "version": attr.string(
            doc = "Version to download (e.g., '0.1.0-rc1')",
            mandatory = True,
        ),
        "platform": attr.string(
            doc = "Platform key in the JSON registry (defaults to trying 'wasm' then 'wasm_component')",
        ),
        "filename": attr.string(
            doc = "Output filename (defaults to {tool_name}.wasm)",
        ),
    },
    doc = """Download a WASM component using the centralized JSON registry.

This is the registry-backed equivalent of http_file for WASM components.
All checksums are verified against //checksums/tools/{tool_name}.json.

Example:
    wasm_component_download(
        name = "loom_wasm",
        tool_name = "loom",
        version = "0.1.0-rc1",
        filename = "loom.wasm",
    )

Then reference as @loom_wasm//file in build rules (matches http_file structure).
""",
)
