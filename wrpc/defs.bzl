"""Bazel rules for wrpc (WebAssembly Component RPC)

Modernized to follow Bazel best practices:
- Uses ctx.actions.run() for build-time actions
- Cross-platform Python launchers for executable rules
- No shell script generation
"""

def _wrpc_bindgen_impl(ctx):
    """Implementation of wrpc_bindgen rule

    Generates language bindings for wrpc from WIT interfaces.
    Uses ctx.actions.run() for direct tool invocation (Bazel best practice).

    Note: This rule uses wit-bindgen-wrpc (the binding generator), not wrpc-wasmtime
    (the RPC runtime). wrpc-wasmtime is used by wrpc_serve and wrpc_invoke rules.
    """

    # Get the wasm toolchain (which includes wit-bindgen-wrpc)
    wasm_toolchain = ctx.toolchains["//toolchains:wasm_tools_toolchain_type"]
    wit_bindgen_wrpc = wasm_toolchain.wit_bindgen_wrpc

    # Output files
    output_dir = ctx.actions.declare_directory(ctx.attr.name + "_bindings")

    # Input WIT file
    wit_file = ctx.file.wit

    # Build command arguments for wit-bindgen-wrpc
    args = ctx.actions.args()
    args.add(ctx.attr.language)  # wit-bindgen-wrpc <language> <options>
    args.add("--world", ctx.attr.world)
    args.add("--out-dir", output_dir.path)
    args.add(wit_file.path)

    # Run wit-bindgen-wrpc - uses ctx.actions.run() (Bazel best practice)
    ctx.actions.run(
        executable = wit_bindgen_wrpc,
        arguments = [args],
        inputs = [wit_file],
        outputs = [output_dir],
        mnemonic = "WitBindgenWrpc",
        progress_message = "Generating wrpc bindings for {}".format(ctx.attr.name),
    )

    return [
        DefaultInfo(files = depset([output_dir])),
        OutputGroupInfo(
            bindings = depset([output_dir]),
        ),
    ]

wrpc_bindgen = rule(
    implementation = _wrpc_bindgen_impl,
    attrs = {
        "wit": attr.label(
            doc = "WIT file defining the interface",
            allow_single_file = [".wit"],
            mandatory = True,
        ),
        "world": attr.string(
            doc = "WIT world to generate bindings for",
            mandatory = True,
        ),
        "language": attr.string(
            doc = "Target language for bindings (rust, go, etc.)",
            default = "rust",
            values = ["rust", "go"],
        ),
    },
    toolchains = ["//toolchains:wasm_tools_toolchain_type"],
    doc = "Generate language bindings for wrpc from WIT interfaces",
)

# Cross-platform Python launcher template for wrpc_serve
_SERVE_LAUNCHER_TEMPLATE = '''#!/usr/bin/env python3
"""Cross-platform wrpc serve launcher

Generated by rules_wasm_component wrpc_serve rule.
This launcher works on Windows, macOS, and Linux.
"""
import os
import subprocess
import sys

def main():
    # Configuration (substituted at generation time)
    wrpc_path = {wrpc_path!r}
    component_path = {component_path!r}
    transport = {transport!r}
    address = {address!r}

    # Resolve paths relative to runfiles
    if "RUNFILES_DIR" in os.environ:
        runfiles = os.environ["RUNFILES_DIR"]
    else:
        # Fallback: assume we're in the workspace root
        runfiles = os.path.dirname(os.path.abspath(__file__))

    # Build full paths
    full_wrpc = os.path.join(runfiles, wrpc_path)
    full_component = os.path.join(runfiles, component_path)

    # Check if files exist
    if not os.path.exists(full_wrpc):
        # Try without runfiles prefix
        full_wrpc = wrpc_path
    if not os.path.exists(full_component):
        full_component = component_path

    print(f"Starting wrpc server...")
    print(f"Component: {{full_component}}")
    print(f"Transport: {{transport}}")
    print(f"Address: {{address}}")

    # Build command
    cmd = [
        full_wrpc,
        "serve",
        "--component", full_component,
        "--transport", transport,
        "--address", address,
    ]

    # Execute wrpc
    try:
        result = subprocess.run(cmd)
        sys.exit(result.returncode)
    except FileNotFoundError:
        print(f"Error: wrpc not found at {{full_wrpc}}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\\nServer stopped")
        sys.exit(0)

if __name__ == "__main__":
    main()
'''

def _wrpc_serve_impl(ctx):
    """Implementation of wrpc_serve rule

    Creates a cross-platform Python launcher to serve a WebAssembly component via wrpc.
    Replaces shell script generation with Python for Windows/macOS/Linux compatibility.
    """

    # Get the wasm toolchain (which includes wrpc)
    wasm_toolchain = ctx.toolchains["//toolchains:wasm_tools_toolchain_type"]
    wrpc = wasm_toolchain.wrpc

    # Component to serve
    component = ctx.file.component

    # Create cross-platform Python launcher
    launcher = ctx.actions.declare_file(ctx.attr.name + "_serve.py")

    launcher_content = _SERVE_LAUNCHER_TEMPLATE.format(
        wrpc_path = wrpc.short_path,
        component_path = component.short_path,
        transport = ctx.attr.transport,
        address = ctx.attr.address,
    )

    ctx.actions.write(
        output = launcher,
        content = launcher_content,
        is_executable = True,
    )

    # Create runfiles with wrpc and component
    runfiles = ctx.runfiles(files = [wrpc, component])

    return [
        DefaultInfo(
            files = depset([launcher]),
            executable = launcher,
            runfiles = runfiles,
        ),
    ]

wrpc_serve = rule(
    implementation = _wrpc_serve_impl,
    attrs = {
        "component": attr.label(
            doc = "WebAssembly component to serve",
            allow_single_file = [".wasm"],
            mandatory = True,
        ),
        "transport": attr.string(
            doc = "Transport protocol (tcp, nats, unix, quic)",
            default = "tcp",
            values = ["tcp", "nats", "unix", "quic"],
        ),
        "address": attr.string(
            doc = "Address to bind server to",
            default = "0.0.0.0:8080",
        ),
    },
    toolchains = ["//toolchains:wasm_tools_toolchain_type"],
    executable = True,
    doc = "Serve a WebAssembly component via wrpc (cross-platform)",
)

# Cross-platform Python launcher template for wrpc_invoke
_INVOKE_LAUNCHER_TEMPLATE = '''#!/usr/bin/env python3
"""Cross-platform wrpc invoke launcher

Generated by rules_wasm_component wrpc_invoke rule.
This launcher works on Windows, macOS, and Linux.
"""
import os
import subprocess
import sys

def main():
    # Configuration (substituted at generation time)
    wrpc_path = {wrpc_path!r}
    function = {function!r}
    transport = {transport!r}
    address = {address!r}

    # Resolve paths relative to runfiles
    if "RUNFILES_DIR" in os.environ:
        runfiles = os.environ["RUNFILES_DIR"]
    else:
        runfiles = os.path.dirname(os.path.abspath(__file__))

    # Build full path to wrpc
    full_wrpc = os.path.join(runfiles, wrpc_path)
    if not os.path.exists(full_wrpc):
        full_wrpc = wrpc_path

    print(f"Invoking wrpc function...")
    print(f"Function: {{function}}")
    print(f"Transport: {{transport}}")
    print(f"Address: {{address}}")

    # Build command
    cmd = [
        full_wrpc,
        "invoke",
        "--function", function,
        "--transport", transport,
        "--address", address,
    ]

    # Add any additional arguments passed to the launcher
    for arg in sys.argv[1:]:
        cmd.extend(["--arg", arg])

    # Execute wrpc
    try:
        result = subprocess.run(cmd)
        sys.exit(result.returncode)
    except FileNotFoundError:
        print(f"Error: wrpc not found at {{full_wrpc}}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
'''

def _wrpc_invoke_impl(ctx):
    """Implementation of wrpc_invoke rule

    Creates a cross-platform Python launcher to invoke a function on a remote
    WebAssembly component via wrpc.
    Replaces shell script generation with Python for Windows/macOS/Linux compatibility.
    """

    # Get the wasm toolchain (which includes wrpc)
    wasm_toolchain = ctx.toolchains["//toolchains:wasm_tools_toolchain_type"]
    wrpc = wasm_toolchain.wrpc

    # Create cross-platform Python launcher
    launcher = ctx.actions.declare_file(ctx.attr.name + "_invoke.py")

    launcher_content = _INVOKE_LAUNCHER_TEMPLATE.format(
        wrpc_path = wrpc.short_path,
        function = ctx.attr.function,
        transport = ctx.attr.transport,
        address = ctx.attr.address,
    )

    ctx.actions.write(
        output = launcher,
        content = launcher_content,
        is_executable = True,
    )

    # Create runfiles with wrpc
    runfiles = ctx.runfiles(files = [wrpc])

    return [
        DefaultInfo(
            files = depset([launcher]),
            executable = launcher,
            runfiles = runfiles,
        ),
    ]

wrpc_invoke = rule(
    implementation = _wrpc_invoke_impl,
    attrs = {
        "function": attr.string(
            doc = "Function to invoke on remote component",
            mandatory = True,
        ),
        "transport": attr.string(
            doc = "Transport protocol (tcp, nats, unix, quic)",
            default = "tcp",
            values = ["tcp", "nats", "unix", "quic"],
        ),
        "address": attr.string(
            doc = "Address of the remote component",
            default = "localhost:8080",
        ),
    },
    toolchains = ["//toolchains:wasm_tools_toolchain_type"],
    executable = True,
    doc = "Invoke a function on a remote WebAssembly component via wrpc (cross-platform)",
)
